#!/usr/bin/env python3

import argparse
import enum
import io
import json
import os
import sys
import typing

import requests
from requests.adapters import HTTPAdapter, Retry


class Locale(enum.Enum):
    enUS = 'enUS'
    deDE = 'deDE'
    esES = 'esES'
    esMX = 'esMX'
    frFR = 'frFR'
    itIT = 'itIT'
    koKR = 'koKR'
    ptBR = 'ptBR'
    ruRU = 'ruRU'
    zhCN = 'zhCN'
    zhTW = 'zhTW'

    def name(self):
        if self == Locale.deDE:
            return 'Deutsch'
        elif self == Locale.esES:
            return 'Español (EU)'
        elif self == Locale.esMX:
            return 'Español (AL)'
        elif self == Locale.frFR:
            return 'Français'
        elif self == Locale.itIT:
            return 'Italiano'
        elif self == Locale.koKR:
            return '한국어'
        elif self == Locale.ptBR:
            return 'Português'
        elif self == Locale.ruRU:
            return 'Pусский'
        elif self == Locale.zhCN:
            return '简体中文'
        elif self == Locale.zhTW:
            return '繁體中文'


def read_translation_table(f: typing.TextIO):
    import itertools
    iter = itertools.dropwhile(lambda line: line.rstrip() != r"L = {", f)
    iter = itertools.islice(iter, 1, None)
    iter = itertools.takewhile(lambda line: line.rstrip() != r"};", iter)
    return f'{{\n{"".join(iter)}}}'


def cf_prepare_session():
    """
    Prepares a CF API exchange session with an API token sourced from the
    local environment and retry logic attached to deal with the CF API's
    ever-present desire to just decide it doesn't want to work.
    """
    session = requests.Session()
    session.mount('https://', HTTPAdapter(max_retries=Retry(total=0, backoff_factor=1, status_forcelist=[500])))
    session.headers['x-api-token'] = os.getenv('CF_API_KEY')

    return session


def cf_upload_translations(locale: Locale, *, delete_missing_phrases: bool, project_id: str):
    with io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8') as r:
        translations = read_translation_table(r)

    if not project_id or int(project_id) <= 0:
        print(translations)
        return

    session = cf_prepare_session()
    res = session.post(
        f'https://wow.curseforge.com/api/projects/{project_id}/localization/import',
        files={
            'metadata': (None, json.dumps({
                'language': locale.value,
                'formatType': 'SimpleTable',
                'missing-phrase-handling': 'DeletePhrase' if delete_missing_phrases else 'DoNothing',
            })),
            'localizations': (None, translations),
        }
    )
    res.raise_for_status()


def cf_download_translations(locale: Locale, *, project_id: str):
    url = f"https://wow.curseforge.com/api/projects/{project_id}/localization/export"
    params = {'lang': locale.value, 'export-type': 'Table', 'unlocalized': 'Ignore'}

    session = cf_prepare_session()
    res = session.get(url, params=params)
    res.raise_for_status()
    contents = res.content.decode('utf-8').replace('\r\n', '\n')

    with io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8') as w:
        w.write(f"""\
-- Copyright The Total RP 3 Authors
-- SPDX-License-Identifier: Apache-2.0

-- THIS FILE IS AUTOMATICALLY GENERATED.
-- ALL MODIFICATIONS TO THIS FILE WILL BE LOST.

local _, TRP3_API = ...;

local L;

L = {contents[4:]};

TRP3_API.loc:RegisterNewLocale("{locale.value}", "{locale.name()}", L);
""")

# fmt: off

parser = argparse.ArgumentParser(prog='upload-localization.py', description='CurseForge localization toolkit.')
commands = parser.add_subparsers(title='commands', metavar=None)

download = commands.add_parser('download', help='Fetches translation strings from CurseForge')
download.add_argument('-l', '--locale', help='Locale to download.', required=True, type=Locale)
download.add_argument('-p', '--project-id', help='CurseForge project ID', required=True)
download.set_defaults(func=lambda args: cf_download_translations(args.locale, project_id=args.project_id))

upload = commands.add_parser('upload', help='Uploads translation strings to CurseForge')
upload.add_argument('-d', '--delete-missing-phrases', help='Mark missing phrases as deleted.', action='store_true')
upload.add_argument('-l', '--locale', help='Locale to upload.', required=True, type=Locale)
upload.add_argument('-p', '--project-id', help='CurseForge project ID')
upload.set_defaults(func=lambda args: cf_upload_translations(args.locale, delete_missing_phrases=args.delete_missing_phrases, project_id=args.project_id))

# fmt: on

args = parser.parse_args()

if 'func' in args:
    args.func(args)
else:
    parser.print_help()
